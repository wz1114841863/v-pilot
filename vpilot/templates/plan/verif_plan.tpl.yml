# vpilot/templates/plan/verif_plan.tpl.yml
# <验证计划>


# --- (v-pilot 自动填充) ---
linked_design_spec: "" # (e.g., "accu.design_spec.final.yml")


verification_strategy:
  - "采用 UVM (pyuvm) + Cocotb (BFM) 架构."
  - "BFM (base_bfm.py) 封装所有信号时序, UVM (driver/monitor) 调用 BFM."
  - "Scoreboard 采用 'uvm_tlm_analysis_fifo' 异步拉取模式."
  - "重点覆盖: 功能正确性/协议时序/边界条件."

verification_points:
  - feature: "复位测试 (Reset)"
    description: "验证异步/同步复位后, 所有内部状态和输出是否恢复到默认值."
    # [!!] 关键:
    # 这里的 'test_scenarios' 列表将 *直接* 驱动 LLM
    # 在下面的 'sequence_library' (蓝图部分) 中生成对应的序列
    test_scenarios:
      - "场景1: 上电后立即复位 (SanityCheckTest)"
      - "场景2: 正常数据流中复位 (DataResetTest)"
      - "场景3: 流水线满载时复位 (FullResetTest)"

    coverage_to_check: # (LLM 填充, 用于指导 coverage.py)
      - "cp_reset_during_active_transaction"

  - feature: "基本数据运算 (e.g., 累加)"
    description: "验证核心功能在典型输入下的正确性."
    test_scenarios:
      - "场景1: 零值累加 (BasicDataTest)"
      - "场景2: 连续正值累加 (PositiveDataTest)"
      - "场景3: 正负交替累加 (MixedDataTest)"

    corner_cases:
      - "输入为最大值"
      - "输入为最小值"
      - "累加结果溢出 (如果设计支持溢出标志)"

    coverage_to_check:
      - "cp_input_range: (min, 0, max)"
      - "cp_output_overflow: 是否触发溢出"

  - feature: "数据冒险/旁路逻辑 (Data Hazards)"
    description: "验证流水线中, 依赖数据是否能被正确传递或暂停."
    test_scenarios:
      - "场景1: 读后写 (RAW) 冒险 (RawHazardTest)"

    coverage_to_check:
      - "cp_bypass_path_used"
      - "cp_stall_cycles"

  # ... (LLM 应根据 'design_spec.yml' 继续添加其他功能点) ...



# [!!] 关键: UVM 拓扑 (用于 env.py)
# LLM 必须根据上面的 'verification_points' 填充这部分
uvm_topology:
  agents:
    - name: "input_agent"  # (Env 将创建: self.input_agent)
      is_active: 1          # (1=ACTIVE, 0=PASSIVE)
      description: "驱动 DUT 的输入端口"

    - name: "output_agent"
      is_active: 0
      description: "监视 DUT 的输出端口"

  scoreboards:
    - name: "scoreboard"
      description: "比对输入和输出"
      # [!!] 关键: v-pilot 需要这个连接信息 (用于 env.py)
      expected_fifo_monitor: "input_agent" # (连接: input_agent.monitor.ap -> scoreboard.expected_fifo)
      actual_fifo_monitor: "output_agent"  # (连接: output_agent.monitor.ap -> scoreboard.actual_fifo)

  coverage_collectors:
    - name: "coverage"
      description: "收集功能覆盖率"
      monitors_to_subscribe:
        - "input_agent"
        - "output_agent"

# [!!] 关键: 测试序列库 (用于 sequence_lib.py 和 test_lib.py)
# LLM 必须确保此列表与 'verification_points.test_scenarios' 中括号内的名称 *一致*
sequence_library:
  - name: "SanityCheckTest"
    description: "冒烟测试, 运行一个空序列以确保平台能启动并复位."
    seq_to_run: "empty_seq" # (v-pilot 将识别这个特殊关键字)

  - name: "DataResetTest"
    description: "实现 '正常数据流中复位' 场景"
    seq_to_run: "DataResetTestSeq" # (LLM 必须在 sequence_lib.py 中创建这个)

  - name: "FullResetTest"
    description: "实现 '流水线满载时复位' 场景"
    seq_to_run: "FullResetTestSeq"

  - name: "BasicDataTest"
    description: "实现 '零值累加' 场景"
    seq_to_run: "BasicDataTestSeq"

  # ... (LLM 必须为 *所有* 场景填充) ...

# [!!] 关键: 功能覆盖点 (用于 coverage.py)
# LLM 必须确保此列表与 'verification_points.coverage_to_check' *一致*
coverage_points:
  - name: "cp_input_range"
    description: "覆盖输入数据的边界"
    item_field: "data_in" # (来自 seq_item.py)
    bins: "list(range(0, 256, 16))" # (Python 代码字符串)

  - name: "cp_output_overflow"
    description: "覆盖溢出标志"
    item_field: "overflow" # (来自 seq_item.py)
    bins: "[0, 1]"

  - name: "cp_reset_during_active_transaction"
    description: "在有效传输期间触发复位 (可能需要 cross)"
    # ...
